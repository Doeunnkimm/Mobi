# SSR과 CSR의 차이

SSR(서버 사이드 렌더링)과 CSR(클라이언트 사이드 렌더링)은 웹 애플리케이션의 렌더링 방식을 나타내는 개념들 중 일부입니다.

둘은 렌더링 방식에 있어 차이가 있기 때문에 사용자 경험이나, 성능, 검색 엔진 최적화 등에서 차이가 있는데요! 이에 대해 자세히 알아보려고 합니다.

## 🤔 렌더링, 화면에 그려지는..그런거?

### 렌더링?

```
⭐️ 화면에 표시할 웹 페이지를 만드는 과정

   구체적으로는 HTML, CSS, JS 등 웹 사이트를 위한 자원들이 브라우저에서 출력되는 과정
```

### 브라우저?

브라우저에서 렌더링되는 과정을 살펴보기 전에 브라우저부터 알아봅시다. 브라우저는 흔히 인터넷을 접속할 때 사용하는 `Chrome`, `Safari` 등을 말합니다.

```
⭐️ 브라우저는 유저가 선택한 자원을 서버로부터 받아와서 보여준다.
   받아온 자원들을 렌더링 과정을 통해 유저에게 보여주게 된다.
```

### 브라우저 렌더링 과정

위에서 정리한 내용들을 바탕으로 정리해보면, 브라우저 렌더링이란 다음과 같습니다.

```
⭐️ 브라우저 렌더링이란
   유저가 선택한 자원을 서버로부터 받아 브라우저에 출력하는 과정!
```

출력하는 과정이라고 했죠? 그럼 어떤 과정을 거치는지도 알아봐야겠습니다.

```
⭐️ 렌더링의 기본적인 동작 과정

   1. HTML 파일과 CSS 파일을 파싱해서 각각 Tree를 만든다. (Parsing)
   2. 두 Tree를 결합하여 Rendering Tree를 만든다. (Style)
   3. Rendering Tree에서 각 노드의 위치와 크기를 계산한다. (Layout)
   4. 계산된 값을 이용해 각 노드를 화면상의 실제 픽셀로 변환하고, 레이어를 만든다. (Paint)
   5. 레이어를 합성하여 실제 화면에 나타낸다. (Composite)
```

잠시후 알아보게 될 SSR과 CSR은 **1번 과정에서 차이가 발생**합니다.

### 미리 알아보는 SSR과 CSR

방금 1번 과정 즉, 파싱하여 Tree를 만드는 과정에서 차이가 발생한다고 했는데요!

```
⭐️ SSR(서버 사이드 렌더링)
   - 서버가 클라이언트 요청에 대해 HTML과 CSS를 파싱하여 렌더링 트리를 만든다.
   - 이 렌더링 트리는 클라이언트에게 미리 렌더링된 형태의 HTML로 전송
   - 클라이언트는 미리 렌더링된 HTML을 받아 화면에 표시

⭐️ CSR(클라이언트 사이드 렌더링)
   - 서버가 초기에 빈 페이지나 최소한의 마크업을 제공
   - 클라이언트는 이 초기 마크업을 받은 후, JS가 실행되어 동적으로 필요한 데이터와 컴포넌트를 가져와 렌더링 트리를 완성
   - 따라서, 초기에 렌더링 트리가 완성되지 않은 상태 → JS가 실행되어 렌더링 트리가 완성되고 화면에 표시
```

```
🔥 요약
   SSR: 서버 측에서 초기 HTML을 렌더링
   CSR: 클라이언트 측에서 JS를 사용해 초기 마크업을 완성하고 렌더링
```

## 🤔 잠깐!! 용어 정리

본격적으로 SSR과 CSR을 알아보기 전에 보다 나은 이해를 위해 알고 갈 용어에 대해 정리해 봅시다.

아래는 **성능**과 관련된 용어입니다.

- [TTFB(Time to First Byte)](https://web.dev/ttfb/): 링크를 클릭하고 콘텐츠의 첫 번째 비트가 들어오는 시간
- [FCP(First Contentful Paint)](https://web.dev/fcp/): 요청된 내용이 볼 수 있게 되는 시간
- [INP(Interaction to Next Paint)](https://web.dev/inp/): 페이지가 사용자 입력에 일관되게 빠르게 응답하는지 여부를 평가
- [TBT(Total Blocking Time)](https://web.dev/tbt/): 사용자 입력에 응답하지 못하도록 차단된 총 시간을 측정.
- [TTI(Time to Interactive)](https://web.dev/i18n/ko/tti/): 상호작용까지의 시간

## 🤔 SSR(서버 사이드 렌더링)

### 🔥 pre-rendering

```
⭐️ SSR은 페이지에 대한 탐색에 대해 페이지의 전체 HTML을 생성하여 응답한다.

→ pre-rendering (사전 렌더링)
```

#### 👏 사전 렌더링이 가지는 강점

사전 렌더링은 서버에서 **미리 HTML을 그려서 클라이언트에게 제공**하는 것입니다.

이게 뭐가 좋은걸까요?

```
👍 강점 1. 빠른 초기 로딩 속도 (빠른 FCP)
```

사전 렌더링된 HTML 파일은 이미 서버에서 미리 렌더링되어 즉, 모든 DOM 요소가 포함된 상태로 클라이언트에게 오기 때문에 사용자가 **웹 페이지에 접근할 때 바로 표시가 가능**합니다.

이는 곧, 초기 로딩 속도 즉, 사용자가 빈 화면을 보고 있는 시간이 줄어들어 **사용자는 더 빠르게 컨텐츠를 볼 수 있습니다.**

<p align="center"><img src="https://web-dev.imgix.net/image/T4FyVKpzu4WKF1kBNvXepbi08t52/WOL6PIpIQHpqsgtKwbJv.png?auto=format&w=1428"  width="60%"/></p>

```
👍 강점 2. 검색 엔진 최적화(SEO)
```

검색 엔진이 웹 사이트를 검색 결과에 노출하기 전에 웹사이트는 분석을 받습니다.

이때 SSR의 경우 서버에서 pre-rendering된 HTML 즉, **페이지의 DOM이 포함된 상태를 처음부터 받게** 됩니다. 따라서 **검색 엔진은 해당 HTML를 분석**하게 됩니다.

반면, **CSR(클라이언트 사이드 렌더링)의 경우**, 처음에 빈 화면 또는 최소한의 요소를 받기 때문에 **검색 엔진에서 분석할 요소들이 부족한 것**입니다.

### 🔥 Hydration

위에서 미리 HTML을 렌더링하는 pre-rendering에 대해 알아봤습니다. 그래서 이걸 클라이언트에게 넘긴다고 했죠?

그럼 **JavaScript 파일은 어떻게 언제 전달**해주는 걸까요?

```
⭐️ hydration
   마른 HTML에 이벤트 핸들러를 연결(수분 공급)하는 과정 !
```

### 🔥 단점

```
👎 단점 1. 링크 이동 시마다 호출
```

SSR을 사용하는 경우 링크 이동 클릭마다 해당 HTML 파일 자체를 서버에 요청하기 때문에 응답까지의 화면 깜빡임 현상이 있을 수 있습니다.

이 말은 곧, 서버에 부담이 될 수 있음을 의미하기도 합니다.

```
➕ Next.js CSR과 SSR을 병행하여 사용하기 때문에 위 문제를 해결!
```

## 🤔 CSR (클라이언트 사이드 렌더링)

### 🔥 클라이언트 측에서 렌더링 작업

```
⭐️ 서버로부터 화면을 그리는 코드를 받아 클라이언트가 그걸 가지고 그리게 된다.
```

<p align="center"><img src="https://web-dev.imgix.net/image/T4FyVKpzu4WKF1kBNvXepbi08t52/JFxoxQe847ntctVOdn5u.png?auto=format&w=1428" width="60%"/></p>

#### 👏 클라이언트 측 렌더링이 가지는 강점

```
👍 강점 1. 페이지 전환이 빠르다
```

CSR의 경우 처음에 모은 JS 파일을 불러오기 때문에 첫 로딩 속도가 오래 걸린다는 단점이 있지만, 그 이후 페이지 전환은 빠르다는 강점이 있습니다.

반면 SSR은 요청하는 화면의 내용을 그때그때 불러오기 때문에 첫 로딩 속도는 빠르지만 페이지 전환 시 깜빡임이 있을 수 있다는 단점이 있습니다.

### 🔥 단점

```
👎 단점 1. 느린 첫 페이지 로딩 속도 (느린 FCP)
```

좀 전에 언급한 것 처럼, 첫 요청 시 모든 리소스를 다운 받기 때문에 처음 로딩이 오래 걸립니다.

```
👎 단점 2. 좋지 못한 SEO
```

처음에 비어있는 DOM부터 받게 되므로 검색 엔진은 제대로 크롤링할 것이 부족합니다. 따라서 별도의 보완작업이 필요로 합니다.

# 참고 문서

- [web.dev - Rendering on the Web](https://web.dev/rendering-on-the-web/)
- [테코블 - 브라우저 렌더링 과정 이해하기](https://tecoble.techcourse.co.kr/post/2021-10-24-browser-rendering/)
- [Chrome Developers - Total Blocking Time](https://developer.chrome.com/docs/lighthouse/performance/lighthouse-total-blocking-time/)
